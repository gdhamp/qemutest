\hypertarget{group__CmplxMatrixMult}{}\section{Complex Matrix Multiplication}
\label{group__CmplxMatrixMult}\index{Complex Matrix Multiplication@{Complex Matrix Multiplication}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
arm\+\_\+status \hyperlink{group__CmplxMatrixMult_ga1adb839ac84445b8c2f04efa43faef35}{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32} (const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+SrcA, const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+SrcB, arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+Dst)
\begin{DoxyCompactList}\small\item\em Floating-\/point Complex matrix multiplication. \end{DoxyCompactList}\item 
arm\+\_\+status \hyperlink{group__CmplxMatrixMult_ga63066615e7d6f6a44f4358725092419e}{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15} (const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+SrcA, const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+SrcB, arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+Dst, q15\+\_\+t $\ast$p\+Scratch)
\begin{DoxyCompactList}\small\item\em Q15 Complex matrix multiplication. \end{DoxyCompactList}\item 
arm\+\_\+status \hyperlink{group__CmplxMatrixMult_gaaf3c0b171ca8412c77bab9fa90804737}{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31} (const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+SrcA, const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+SrcB, arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+Dst)
\begin{DoxyCompactList}\small\item\em Q31 Complex matrix multiplication. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Complex Matrix multiplication is only defined if the number of columns of the first matrix equals the number of rows of the second matrix. Multiplying an {\ttfamily M x N} matrix with an {\ttfamily N x P} matrix results in an {\ttfamily M x P} matrix. When matrix size checking is enabled, the functions check\+: (1) that the inner dimensions of {\ttfamily p\+SrcA} and {\ttfamily p\+SrcB} are equal; and (2) that the size of the output matrix equals the outer dimensions of {\ttfamily p\+SrcA} and {\ttfamily p\+SrcB}. 

\subsection{Function Documentation}
\index{Complex Matrix Multiplication@{Complex Matrix Multiplication}!arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32}}
\index{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32}!Complex Matrix Multiplication@{Complex Matrix Multiplication}}
\subsubsection[{\texorpdfstring{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32(const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+Src\+A, const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+Src\+B, arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$p\+Dst)}{arm_mat_cmplx_mult_f32(const arm_matrix_instance_f32 *pSrcA, const arm_matrix_instance_f32 *pSrcB, arm_matrix_instance_f32 *pDst)}}]{\setlength{\rightskip}{0pt plus 5cm}arm\+\_\+status arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+f32 (
\begin{DoxyParamCaption}
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$}]{p\+SrcA, }
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$}]{p\+SrcB, }
\item[{arm\+\_\+matrix\+\_\+instance\+\_\+f32 $\ast$}]{p\+Dst}
\end{DoxyParamCaption}
)}\hypertarget{group__CmplxMatrixMult_ga1adb839ac84445b8c2f04efa43faef35}{}\label{group__CmplxMatrixMult_ga1adb839ac84445b8c2f04efa43faef35}


Floating-\/point Complex matrix multiplication. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$p\+SrcA} & points to the first input complex matrix structure \\
\hline
\mbox{\tt in}  & {\em $\ast$p\+SrcB} & points to the second input complex matrix structure \\
\hline
\mbox{\tt out}  & {\em $\ast$p\+Dst} & points to output complex matrix structure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns either {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+I\+S\+M\+A\+T\+CH} or {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+U\+C\+C\+E\+SS} based on the outcome of size checking. 
\end{DoxyReturn}
\index{Complex Matrix Multiplication@{Complex Matrix Multiplication}!arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15}}
\index{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15}!Complex Matrix Multiplication@{Complex Matrix Multiplication}}
\subsubsection[{\texorpdfstring{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15(const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+Src\+A, const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+Src\+B, arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$p\+Dst, q15\+\_\+t $\ast$p\+Scratch)}{arm_mat_cmplx_mult_q15(const arm_matrix_instance_q15 *pSrcA, const arm_matrix_instance_q15 *pSrcB, arm_matrix_instance_q15 *pDst, q15_t *pScratch)}}]{\setlength{\rightskip}{0pt plus 5cm}arm\+\_\+status arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q15 (
\begin{DoxyParamCaption}
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$}]{p\+SrcA, }
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$}]{p\+SrcB, }
\item[{arm\+\_\+matrix\+\_\+instance\+\_\+q15 $\ast$}]{p\+Dst, }
\item[{q15\+\_\+t $\ast$}]{p\+Scratch}
\end{DoxyParamCaption}
)}\hypertarget{group__CmplxMatrixMult_ga63066615e7d6f6a44f4358725092419e}{}\label{group__CmplxMatrixMult_ga63066615e7d6f6a44f4358725092419e}


Q15 Complex matrix multiplication. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$p\+SrcA} & points to the first input complex matrix structure \\
\hline
\mbox{\tt in}  & {\em $\ast$p\+SrcB} & points to the second input complex matrix structure \\
\hline
\mbox{\tt out}  & {\em $\ast$p\+Dst} & points to output complex matrix structure \\
\hline
\mbox{\tt in}  & {\em $\ast$p\+Scratch} & points to the array for storing intermediate results \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns either {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+I\+S\+M\+A\+T\+CH} or {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+U\+C\+C\+E\+SS} based on the outcome of size checking.
\end{DoxyReturn}
\begin{DoxyParagraph}{Conditions for optimum performance}
Input, output and state buffers should be aligned by 32-\/bit
\end{DoxyParagraph}
\begin{DoxyParagraph}{Restrictions}
If the silicon does not support unaligned memory access enable the macro U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+D\+I\+S\+A\+B\+LE In this case input, output, scratch buffers should be aligned by 32-\/bit
\end{DoxyParagraph}
{\bfseries Scaling and Overflow Behavior\+:}

\begin{DoxyParagraph}{}
The function is implemented using a 64-\/bit internal accumulator. The inputs to the multiplications are in 1.\+15 format and multiplications yield a 2.\+30 result. The 2.\+30 intermediate results are accumulated in a 64-\/bit accumulator in 34.\+30 format. This approach provides 33 guard bits and there is no risk of overflow. The 34.\+30 result is then truncated to 34.\+15 format by discarding the low 15 bits and then saturated to 1.\+15 format.
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
Refer to {\ttfamily \hyperlink{group__MatrixMult_ga08f37d93a5bfef0c5000dc5e0a411f93}{arm\+\_\+mat\+\_\+mult\+\_\+fast\+\_\+q15()}} for a faster but less precise version of this function. 
\end{DoxyParagraph}
\index{Complex Matrix Multiplication@{Complex Matrix Multiplication}!arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31}}
\index{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31@{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31}!Complex Matrix Multiplication@{Complex Matrix Multiplication}}
\subsubsection[{\texorpdfstring{arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31(const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+Src\+A, const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+Src\+B, arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$p\+Dst)}{arm_mat_cmplx_mult_q31(const arm_matrix_instance_q31 *pSrcA, const arm_matrix_instance_q31 *pSrcB, arm_matrix_instance_q31 *pDst)}}]{\setlength{\rightskip}{0pt plus 5cm}arm\+\_\+status arm\+\_\+mat\+\_\+cmplx\+\_\+mult\+\_\+q31 (
\begin{DoxyParamCaption}
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$}]{p\+SrcA, }
\item[{const arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$}]{p\+SrcB, }
\item[{arm\+\_\+matrix\+\_\+instance\+\_\+q31 $\ast$}]{p\+Dst}
\end{DoxyParamCaption}
)}\hypertarget{group__CmplxMatrixMult_gaaf3c0b171ca8412c77bab9fa90804737}{}\label{group__CmplxMatrixMult_gaaf3c0b171ca8412c77bab9fa90804737}


Q31 Complex matrix multiplication. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$p\+SrcA} & points to the first input complex matrix structure \\
\hline
\mbox{\tt in}  & {\em $\ast$p\+SrcB} & points to the second input complex matrix structure \\
\hline
\mbox{\tt out}  & {\em $\ast$p\+Dst} & points to output complex matrix structure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The function returns either {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+I\+S\+M\+A\+T\+CH} or {\ttfamily A\+R\+M\+\_\+\+M\+A\+T\+H\+\_\+\+S\+U\+C\+C\+E\+SS} based on the outcome of size checking.
\end{DoxyReturn}
{\bfseries Scaling and Overflow Behavior\+:}

\begin{DoxyParagraph}{}
The function is implemented using an internal 64-\/bit accumulator. The accumulator has a 2.\+62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit. There is no saturation on intermediate additions. Thus, if the accumulator overflows it wraps around and distorts the result. The input signals should be scaled down to avoid intermediate overflows. The input is thus scaled down by log2(num\+Cols\+A) bits to avoid overflows, as a total of num\+ColsA additions are performed internally. The 2.\+62 accumulator is right shifted by 31 bits and saturated to 1.\+31 format to yield the final result. 
\end{DoxyParagraph}
